---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by knia.
--- DateTime: 2019/3/8 18:42
---Description: 工具类
---
--获取table长度
function table_leng(t)
    local leng=0
    for k, v in pairs(t) do
        leng=leng+1
    end
    return leng;
end

--table升序排列
function table_arrange(t)
    local keyTest ={}
    for i in pairs(t) do
        table.insert(keyTest,i)
    end
    table.sort(keyTest,function(a,b)return (tonumber(a) <  tonumber(b)) end)
    local result = { }
    for i,v in pairs(keyTest) do
        table.insert(result,t[v])
    end
    return result
end

--清除html标签
function removeHtmlMark(str)
    str = string.gsub(str, '<script[%a%A]->[%a%A]-</script>', '')
    str = string.gsub(str, '<style[%a%A]->[%a%A]-</style>', '')
    str = string.gsub(str, '<[%a%A]->', '')
    return str
end

function ToStringEx(value)
    if type(value)=='table' then
       return TableToStr(value)
    elseif type(value)=='string' then
        return "\'"..value.."\'"
    else
       return tostring(value)
    end
end


--字符串转table
function StrToTable(str)
    if str == nil or type(str) ~= "string" then
        return
    end
    return loadstring("return " .. str)()
end


--table转string
function TableToStr(t)
    if t == nil then return "" end
    local retstr= "{"

    local i = 1
    for key,value in pairs(t) do
        local signal = ","
        if i==1 then
          signal = ""
        end

        if key == i then
            retstr = retstr..signal..ToStringEx(value)
        else
            if type(key)=='number' or type(key) == 'string' then
                retstr = retstr..signal..'['..ToStringEx(key).."]="..ToStringEx(value)
            else
                if type(key)=='userdata' then
                    retstr = retstr..signal.."*s"..TableToStr(getmetatable(key)).."*e".."="..ToStringEx(value)
                else
                    retstr = retstr..signal..key.."="..ToStringEx(value)
                end
            end
        end

        i = i+1
    end

     retstr = retstr.."}"
     return retstr
end

function table2json(t)
  local function serialize(tbl)
    local tmp = {}
    for k, v in pairs(tbl) do
      local k_type = type(k)
      local v_type = type(v)
      local key = (k_type == "string" and "\"" .. k .. "\":")
        or (k_type == "number" and "")
      local value = (v_type == "table" and serialize(v))
        or (v_type == "boolean" and tostring(v))
        or (v_type == "string" and "\"" .. v .. "\"")
        or (v_type == "number" and v)
      tmp[#tmp + 1] = key and value and tostring(key) .. tostring(value) or nil
    end
    if table.maxn(tbl) == 0 then
      return "{" .. table.concat(tmp, ",") .. "}"
    else
      return "[" .. table.concat(tmp, ",") .. "]"
    end
  end
  assert(type(t) == "table")
  return serialize(t)
end

--序列化
function serialize(obj)
    local lua = ""
    local t = type(obj)
    if t == "number" then
        lua = lua .. obj
    elseif t == "boolean" then
        lua = lua .. tostring(obj)
    elseif t == "string" then
        lua = lua .. string.format("%q", obj)
    elseif t == "table" then
        lua = lua .. "{\n"
        for k, v in pairs(obj) do
            lua = lua .. "[" .. serialize(k) .. "]=" .. serialize(v) .. ",\n"
        end
        local metatable = getmetatable(obj)
        if metatable ~= nil and type(metatable.__index) == "table" then
            for k, v in pairs(metatable.__index) do
                lua = lua .. "[" .. serialize(k) .. "]=" .. serialize(v) .. ",\n"
            end
        end
        lua = lua .. "}"
    elseif t == "nil" then
        return nil
    else
        error("can not serialize a " .. t .. " type.")
    end
    return lua
end
--反序列化
function unserialize(lua)
    local t = type(lua)
    if t == "nil" or lua == "" then
        return nil
    elseif t == "number" or t == "string" or t == "boolean" then
        lua = tostring(lua)
    else
        error("can not unserialize a " .. t .. " type.")
    end
    lua = "return " .. lua
    local func = loadstring(lua)
    if func == nil then
        return nil
    end
    return func()
end


--还是打印table
function formatValue(val)
    if type(val) == "string" then
        return string.format("%q", val)
    end
    return tostring(val)
end

function formatTable(t, tabcount)
    tabcount = tabcount or 0
    if tabcount > 5 then
        --防止栈溢出
        return "<table too deep>"..tostring(t)
    end
    local str = ""
    if type(t) == "table" then
        for k, v in pairs(t) do
            local tab = string.rep("\t", tabcount)
            if type(v) == "table" then
                str = str..tab..string.format("[%s] = {", formatValue(k))..'\n'
                str = str..formatTable(v, tabcount + 1)..tab..'},\n'
            else
                str = str..tab..string.format("[%s] = %s", formatValue(k), formatValue(v))..',\n'
            end
        end
    else
        str = str..tostring(t)..'\n'
    end
    return str
end

--重命名技能图片文件
function renameSkillIconFiles()
    require("xml.xml_skill_skillgroup")
    local heroids = cfgControlHero:getAllHeroIds()
    local map = {}
    for i, v in pairs(heroids) do
        for j, k in pairs(cfgControlHero:getAllSkillsById(v)) do
            map[k] = {
                id = k,
                filename = string.match(XML_skill.skillgroup[k].params,"%a+.png")
            }
        end
    end

    function copyFunc(sourcePath,targetPath)
        local rf = io.open(sourcePath,"rb") --使用“rb”打开二进制文件，如果是“r”的话，是使用文本方式打开，遇到‘0’时会结束读取
        local len = rf:seek("end")  --获取文件长度
        rf:seek("set",0)--重新设置文件索引为0的位置
        local data = rf:read(len)  --根据文件长度读取文件数据
        local wf = io.open(targetPath,"wb")  --用“wb”方法写入二进制文件
        wf:write(data,len)
        rf:close()
        wf:close()
    end

    local s = io.popen("dir C:\\Users\\knia\\Desktop\\czjy\\skillicons /b/s")
    local filelist = s:read("*all")

    local start_pos = 0
    local file_not_changed = {}
    while true
    do
        _,end_pos, line = string.find(filelist, "([^\n\r]+.png)", start_pos)

        if not end_pos then
            break
        end
        local folder_filename = string.match(line,"%a+.png")
        local new_name
        for i, v in pairs(map) do
            if v.filename == folder_filename then
                new_name = i..".png"
            end
        end
        if new_name then
            copyFunc(line,"C:\\Users\\knia\\Desktop\\czjy\\skills_rename\\"..new_name)
        else
            table.insert(file_not_changed,line)
        end

        --os.rename(line , string.format("C:\\Users\\knia\\Desktop\\czjy\\战报图片\\技能\\%s.png", name))

        start_pos = end_pos + 1
    end

    print("++++++重命名完成+++++")

    print(formatTable(file_not_changed))
end